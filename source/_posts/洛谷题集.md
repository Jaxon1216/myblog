---
title: 洛谷题集-入门
date: 2025-08-04 22:26:51
categories:
  - study
tags:
  - C++
  - 洛谷
---
# 洛谷题目集

## 目录
1. [数组题目](#数组题目)
2. [字符串题目](#字符串题目)
3. [循环题目](#循环题目)
4. [分支题目](#分支题目)
5. [顺序题目](#顺序题目)

---

## 数组题目

### 神奇的幻方

**题目描述：** 构造一个n×n的幻方，满足每行、每列、两条对角线的和都相等。

**解题思路：** 使用幻方的构造规则，从第一行中间开始，按照特定规则填充数字。

```cpp
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;
    int a[45][45] = {}; // 幻方数组，初始化为0
    int k = 1; // 当前要填入的数字
    int x, y;  // 当前数字的位置

    while (k <= n * n) { // 循环直到填满所有数字
        if (k == 1) { // 第一个数字放在第一行的中间
            x = 1;
            y = n / 2 + 1;
        } else {
            // 根据幻方规则移动位置
            if (x == 1 && y != n) { // 如果在第一行且不在最后一列
                x = n; // 移动到最后一行
                y++;   // 列向右移动
            } else if (y == n && x != 1) { // 如果在最后一列且不在第一行
                x--;   // 行向上移动
                y = 1; // 移动到第一列
            } else if (x == 1 && y == n) { // 如果在第一行最后一列
                x++;   // 行向下移动
            } else {
                if (a[x-1][y+1] != 0) { // 如果右上角已经有数字
                    x++; // 行向下移动
                } else {
                    x--; // 行向上移动
                    y++; // 列向右移动
                }
            }
        }
        a[x][y] = k; // 填入数字
        k++; // 下一个数字
    }

    // 输出幻方
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            cout << a[i][j] << " ";
        }
        cout << "\n";
    }

    return 0;
}
```

### 杨辉三角

**题目描述：** 输入n，输出前n行的杨辉三角。

**解题思路：** 使用二维数组存储，每个数等于它上方两个数之和。

```cpp
#include<iostream>
#include<vector>
using namespace std;

int main(){
    int n;
    cin >> n;
    vector<vector<int>> yanghui(n);

    for(int i = 0; i < n; i++){
        yanghui[i].resize(i + 1);  // 每行的元素个数为 i+1
        yanghui[i][0] = yanghui[i][i] = 1;  // 每行的第一个和最后一个元素为1

        for(int j = 1; j < i; j++){
            yanghui[i][j] = yanghui[i-1][j-1] + yanghui[i-1][j];
        }
    }

    for(int i = 0; i < n; i++){
        for(int j = 0; j <= i; j++){
            cout << yanghui[i][j] << " ";
        }
        cout << endl;
    }

    return 0;
}
```

**优化版本（仅输出）：**
```cpp
#include<iostream>
using namespace std;

int main(){
    int n;
    cin >> n;

    for(int i = 0; i < n; i++){
        int val = 1;
        for(int j = 0; j <= i; j++){
            cout << val << " ";
            val = val * (i - j) / (j + 1);  // 计算下一个值
        }
        cout << endl;
    }

    return 0;
}
```

### 蛇形方阵

**题目描述：** 构造一个n×n的蛇形方阵，数字从1开始按蛇形路径填充。

```cpp
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;
    int a[100][100] = {};
    int num = 1;
    
    for (int i = 0; i < n; i++) {
        if (i % 2 == 0) {  // 偶数行从左到右
            for (int j = 0; j < n; j++) {
                a[i][j] = num++;
            }
        } else {  // 奇数行从右到左
            for (int j = n - 1; j >= 0; j--) {
                a[i][j] = num++;
            }
        }
    }
    
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cout << a[i][j] << " ";
        }
        cout << endl;
    }
    
    return 0;
}
```

### 开灯问题

**题目描述：** 有n盏灯，编号为1到n。第1个人把所有灯都打开，第2个人按下所有编号为2的倍数的开关，第3个人按下所有编号为3的倍数的开关，以此类推。问最后有多少盏灯是亮的。

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n;
    cin >> n;
    vector<bool> lights(n + 1, false);  // false表示灯关闭
    
    for (int i = 1; i <= n; i++) {
        for (int j = i; j <= n; j += i) {
            lights[j] = !lights[j];  // 翻转灯的状态
        }
    }
    
    int count = 0;
    for (int i = 1; i <= n; i++) {
        if (lights[i]) count++;
    }
    
    cout << count << endl;
    return 0;
}
```

### 珠心算测验

**题目描述：** 给定n个数，问有多少个数可以表示为其他两个数的和。

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n;
    cin >> n;
    vector<int> nums(n);
    vector<bool> canSum(20001, false);  // 标记哪些数可以表示为两数之和
    
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }
    
    // 计算所有可能的和
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            canSum[nums[i] + nums[j]] = true;
        }
    }
    
    int count = 0;
    for (int i = 0; i < n; i++) {
        if (canSum[nums[i]]) count++;
    }
    
    cout << count << endl;
    return 0;
}
```

---

## 字符串题目

### 数字反转

**题目描述：** 给定一个数，可以是整数、小数、分数或百分数，请将该数各个位上数字反转得到一个新数。

**解题思路：** 根据不同的数字类型分别处理，注意去除前导零和末尾零。

```cpp
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

// 反转字符串，并去除前导零
string reverseStr(string s) {
    reverse(s.begin(), s.end());
    // 去除前导零
    s.erase(0, s.find_first_not_of('0'));
    // 如果全部是0，保留一个0
    if (s.empty()) s = "0";
    return s;
}

int main() {
    string s;
    cin >> s;
    
    // 判断输入类型
    if (s.find('.') != string::npos) {  // 小数
        int pos = s.find('.');
        string intPart = s.substr(0, pos);
        string decPart = s.substr(pos + 1);
        // 反转整数部分和小数部分
        string newInt = reverseStr(intPart);
        string newDec = reverseStr(decPart);
        // 去除小数部分末尾的0
        newDec.erase(newDec.find_last_not_of('0') + 1);
        if (newDec.empty()) newDec = "0";  // 如果小数部分全为0，保留一个0
        
        cout << newInt << "." << newDec << endl;
    }
    else if (s.find('/') != string::npos) {  // 分数
        int pos = s.find('/');
        string numerator = s.substr(0, pos);
        string denominator = s.substr(pos + 1);
        // 反转分子和分母
        string newNum = reverseStr(numerator);
        string newDen = reverseStr(denominator);
        cout << newNum << "/" << newDen << endl;
    }
    else if (s.find('%') != string::npos) {  // 百分数
        string num = s.substr(0, s.length() - 1);
        string newNum = reverseStr(num);
        cout << newNum << "%" << endl;
    }
    else {  // 整数
        string newNum = reverseStr(s);
        cout << newNum << endl;
    }
    
    return 0;
}
```

### 凯撒密码

**题目描述：** 将字符串中的每个字母向后移动k位，非字母字符保持不变。

```cpp
#include <iostream>
#include <string>
#include <cctype>
using namespace std;

int main() {
    string s;
    int k;
    cin >> s >> k;
    
    for (char& c : s) {
        if (isalpha(c)) {
            char base = isupper(c) ? 'A' : 'a';
            c = (c - base + k) % 26 + base;
        }
    }
    
    cout << s << endl;
    return 0;
}
```

### 统计单词数

**题目描述：** 统计一个单词在文本中出现的次数。

```cpp
#include <iostream>
#include <string>
#include <sstream>
#include <algorithm>
using namespace std;

int main() {
    string word, text;
    getline(cin, word);
    getline(cin, text);
    
    // 转换为小写
    transform(word.begin(), word.end(), word.begin(), ::tolower);
    transform(text.begin(), text.end(), text.begin(), ::tolower);
    
    stringstream ss(text);
    string token;
    int count = 0;
    int firstPos = -1;
    int currentPos = 0;
    
    while (ss >> token) {
        if (token == word) {
            count++;
            if (firstPos == -1) {
                firstPos = currentPos;
            }
        }
        currentPos++;
    }
    
    if (count == 0) {
        cout << -1 << endl;
    } else {
        cout << count << " " << firstPos << endl;
    }
    
    return 0;
}
```

### 大小写转换

**题目描述：** 将字符串中的大写字母转换为小写，小写字母转换为大写。

```cpp
#include <iostream>
#include <string>
#include <cctype>
using namespace std;

int main() {
    string s;
    cin >> s;
    
    for (char& c : s) {
        if (isupper(c)) {
            c = tolower(c);
        } else if (islower(c)) {
            c = toupper(c);
        }
    }
    
    cout << s << endl;
    return 0;
}
```

### 标题统计

**题目描述：** 统计一行文本中字符的个数（不包括空格和换行符）。

```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    string s;
    getline(cin, s);
    
    int count = 0;
    for (char c : s) {
        if (c != ' ' && c != '\n') {
            count++;
        }
    }
    
    cout << count << endl;
    return 0;
}
```

---

## 循环题目

### 冰雹猜想

**题目描述：** 对于任意一个正整数，如果是奇数，则乘3加1；如果是偶数，则除以2。重复这个过程，最终会得到1。

```cpp
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;
    
    while (n != 1) {
        cout << n << " ";
        if (n % 2 == 1) {
            n = n * 3 + 1;
        } else {
            n = n / 2;
        }
    }
    cout << 1 << endl;
    
    return 0;
}
```

### 梦中的统计

**题目描述：** 统计数字0-9在给定范围内出现的次数。

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int m, n;
    cin >> m >> n;
    
    vector<int> count(10, 0);
    
    for (int i = m; i <= n; i++) {
        int num = i;
        while (num > 0) {
            count[num % 10]++;
            num /= 10;
        }
    }
    
    for (int i = 0; i < 10; i++) {
        cout << count[i] << " ";
    }
    cout << endl;
    
    return 0;
}
```

### 门外的树

**题目描述：** 有n棵树，编号为1到n。每次砍掉一段连续的树，问最后剩下多少棵树。

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n, m;
    cin >> n >> m;
    
    vector<bool> trees(n + 1, true);  // true表示树还在
    
    for (int i = 0; i < m; i++) {
        int l, r;
        cin >> l >> r;
        for (int j = l; j <= r; j++) {
            trees[j] = false;  // 砍掉树
        }
    }
    
    int count = 0;
    for (int i = 1; i <= n; i++) {
        if (trees[i]) count++;
    }
    
    cout << count << endl;
    return 0;
}
```

---

## 分支题目

### 旗鼓相当的对手

**题目描述：** 给定n个人的成绩，找出成绩相同的人数最多的成绩。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    int n;
    cin >> n;
    
    vector<int> scores(n);
    for (int i = 0; i < n; i++) {
        cin >> scores[i];
    }
    
    sort(scores.begin(), scores.end());
    
    int maxCount = 1;
    int currentCount = 1;
    int result = scores[0];
    
    for (int i = 1; i < n; i++) {
        if (scores[i] == scores[i-1]) {
            currentCount++;
        } else {
            if (currentCount > maxCount) {
                maxCount = currentCount;
                result = scores[i-1];
            }
            currentCount = 1;
        }
    }
    
    // 检查最后一组
    if (currentCount > maxCount) {
        maxCount = currentCount;
        result = scores[n-1];
    }
    
    cout << result << endl;
    return 0;
}
```

### 不知大小

**题目描述：** 给定三个数，输出它们的最大值和最小值。

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int main() {
    int a, b, c;
    cin >> a >> b >> c;
    
    int max_val = max({a, b, c});
    int min_val = min({a, b, c});
    
    cout << max_val << " " << min_val << endl;
    return 0;
}
```

### 三个骰子

**题目描述：** 掷三个骰子，计算点数和。

```cpp
#include <iostream>
using namespace std;

int main() {
    int a, b, c;
    cin >> a >> b >> c;
    
    int sum = a + b + c;
    cout << sum << endl;
    
    return 0;
}
```

---

## 顺序题目

### 显示屏

**题目描述：** 模拟数字显示屏，用字符画显示数字。

```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    string num;
    cin >> num;
    
    // 数字的字符画表示
    string digits[10][5] = {
        {"###", "# #", "# #", "# #", "###"},  // 0
        {"  #", "  #", "  #", "  #", "  #"},  // 1
        {"###", "  #", "###", "#  ", "###"},  // 2
        {"###", "  #", "###", "  #", "###"},  // 3
        {"# #", "# #", "###", "  #", "  #"},  // 4
        {"###", "#  ", "###", "  #", "###"},  // 5
        {"###", "#  ", "###", "# #", "###"},  // 6
        {"###", "  #", "  #", "  #", "  #"},  // 7
        {"###", "# #", "###", "# #", "###"},  // 8
        {"###", "# #", "###", "  #", "###"}   // 9
    };
    
    // 输出每一行
    for (int row = 0; row < 5; row++) {
        for (char c : num) {
            cout << digits[c - '0'][row] << " ";
        }
        cout << endl;
    }
    
    return 0;
}
```

### 彩票

**题目描述：** 模拟彩票开奖，判断中奖情况。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    vector<int> winning(7);
    vector<int> ticket(7);
    
    // 输入中奖号码
    for (int i = 0; i < 7; i++) {
        cin >> winning[i];
    }
    
    // 输入彩票号码
    for (int i = 0; i < 7; i++) {
        cin >> ticket[i];
    }
    
    // 统计匹配的号码数
    int matches = 0;
    for (int i = 0; i < 7; i++) {
        if (find(winning.begin(), winning.end(), ticket[i]) != winning.end()) {
            matches++;
        }
    }
    
    cout << matches << endl;
    return 0;
}
```

### 工艺品制作

**题目描述：** 计算制作工艺品所需的材料数量。

```cpp
#include <iostream>
using namespace std;

int main() {
    int n, m, k;
    cin >> n >> m >> k;
    
    int total = n * m * k;
    cout << total << endl;
    
    return 0;
}
```

---

## 常用算法模板

### 1. 二分查找
```cpp
int binarySearch(vector<int>& arr, int target) {
    int left = 0, right = arr.size() - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] == target) return mid;
        if (arr[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return -1;
}
```

### 2. 快速排序
```cpp
void quickSort(vector<int>& arr, int left, int right) {
    if (left >= right) return;
    
    int pivot = arr[left];
    int i = left, j = right;
    
    while (i < j) {
        while (i < j && arr[j] >= pivot) j--;
        while (i < j && arr[i] <= pivot) i++;
        if (i < j) swap(arr[i], arr[j]);
    }
    
    arr[left] = arr[i];
    arr[i] = pivot;
    
    quickSort(arr, left, i - 1);
    quickSort(arr, i + 1, right);
}
```

### 3. 深度优先搜索
```cpp
void dfs(vector<vector<int>>& graph, vector<bool>& visited, int node) {
    visited[node] = true;
    cout << node << " ";
    
    for (int neighbor : graph[node]) {
        if (!visited[neighbor]) {
            dfs(graph, visited, neighbor);
        }
    }
}
```

### 4. 广度优先搜索
```cpp
void bfs(vector<vector<int>>& graph, int start) {
    vector<bool> visited(graph.size(), false);
    queue<int> q;
    
    q.push(start);
    visited[start] = true;
    
    while (!q.empty()) {
        int node = q.front();
        q.pop();
        cout << node << " ";
        
        for (int neighbor : graph[node]) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                q.push(neighbor);
            }
        }
    }
}
```

### 5. 动态规划 - 斐波那契
```cpp
int fibonacci(int n) {
    if (n <= 1) return n;
    
    vector<int> dp(n + 1);
    dp[0] = 0;
    dp[1] = 1;
    
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }
    
    return dp[n];
}
```

### 6. 字符串匹配
```cpp
bool isSubstring(string s, string sub) {
    return s.find(sub) != string::npos;
}
```

### 7. 素数筛法
```cpp
vector<bool> sieve(int n) {
    vector<bool> isPrime(n + 1, true);
    isPrime[0] = isPrime[1] = false;
    
    for (int i = 2; i * i <= n; i++) {
        if (isPrime[i]) {
            for (int j = i * i; j <= n; j += i) {
                isPrime[j] = false;
            }
        }
    }
    
    return isPrime;
}
```

### 8. 最大公约数和最小公倍数
```cpp
int gcd(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

int lcm(int a, int b) {
    return a / gcd(a, b) * b;
}
```

### 9. 进制转换
```cpp
string decimalToBinary(int n) {
    if (n == 0) return "0";
    string result = "";
    while (n > 0) {
        result = char('0' + n % 2) + result;
        n /= 2;
    }
    return result;
}

int binaryToDecimal(string binary) {
    int result = 0;
    for (char c : binary) {
        result = result * 2 + (c - '0');
    }
    return result;
}
```

### 10. 排列组合
```cpp
// 计算组合数 C(n,m)
long long combination(int n, int m) {
    if (m > n - m) m = n - m;
    long long result = 1;
    for (int i = 0; i < m; i++) {
        result = result * (n - i) / (i + 1);
    }
    return result;
}
``` 